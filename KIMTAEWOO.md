#GDG Server 5번째 세션 과제
## 목차
[1. 사용자 관점에서의 로그인 과정 흐름](#사용자-관점에서의-로그인-과정-흐름)<br>
[&nbsp;&nbsp;&nbsp;&nbsp;1-1. 사용자가 로그인에 성공 혹은 실패하는 과정](사용자가-로그인에-성공-혹은-실패하는-과정)<br>
[&nbsp;&nbsp;&nbsp;&nbsp;1-2. 로그인 성공 후 사용자에게 제공되는 경험](로그인-성공-후-사용자에게-제공되는-경험)<br>
[2. 서버가 로그인한 사용자를 인식하는 방식](#서버가-로그인한-사용자를-인식하는-방식)<br>
[&nbsp;&nbsp;&nbsp;&nbsp;2-1. 시작하기 전에](#시작하기-전에)<br>
[&nbsp;&nbsp;&nbsp;&nbsp;2-2. 지속 로그인을 위해 쿠키와 세션이 사용되는 방식 및 세션 기반 로그인에서 쿠키의 역할](#지속-로그인을-위해-쿠키와-세션이-사용되는-방식-및-세션-기반-로그인에서-쿠키의-역할)<br>
[&nbsp;&nbsp;&nbsp;&nbsp;2-3. 서버가 로그인한 사용자를 인식하는 방식 결론](#서버가-로그인한-사용자를-인식하는-방식-결론)<br>
[3. 서버 구현시 보안적으로 고려해야할 부분](#서버-구현시-보안적으로-고려해야할-부분)<br>

# 사용자 관점에서의 로그인 과정 흐름
## 사용자가 로그인에 성공 혹은 실패하는 과정
### (1) 회원 가입이 되어있지 않은 경우
로그인 불가능, 회원가입 진행
1. 로그인 아이디를 입력하지 않은 경우 &rightarrow; `"로그인 ID가 필요합니다."`
2. ID, 비밀번호, 이름을 모두 제대로 작성한 경우 &rightarrow; _회원가입 성공_

### (2) 회원가입이 되어있는 경우
ID와 비밀번호를 입력한 뒤 로그인을 시도한다.
1. ID가 서버DB에 없는 경우 &rightarrow; `"회원 정보를 찾을 수 없습니다"`
2. ID는 서버DB에 존재하지만 비밀번호가 DB와 일치하지 않는 겨우 &rightarrow; `"비밀번호가 일치하지 않습니다"`
3. ID와 비밀번호가 모두 DB와 일치하는 경우 &rightarrow; _로그인 성공_

## 로그인 성공 후 사용자에게 제공되는 경험
사용자는 브라우저를 닫거나 쿠키가 만료될 때까지 로그인 상태를 유지한다.<br>

사용자가 로그인에 성공하면, 서버로부터 세션ID가 들어있는 쿠키를 전달받는다.<br>
쿠키를 전달받은 이후 보내는 모든 요청에 사용자는 해당 쿠키를 포함시킨다.<br>
서버는 쿠키를 전달받아 세션ID를 확인한 뒤 요청에 응답한다.<br>

<hr>

# 서버가 로그인한 사용자를 인식하는 방식

## 시작하기 전에
이번 로그인 코드부터는 자바의 **다형성** 개념이 적극적으로 사용됩니다. 다형성은 하나의 참조 변수가 여러 가지 객체를 참조할 수 있는 것을 말합니다.<br>
<img width="300" alt="HttpServletRequest계층도" src="https://github.com/user-attachments/assets/b50145b2-cfdd-4699-a75a-cd8b7a13f16b">
로그인시 가장 먼저 사용되는 `HttpServlettRequest` 클래스의 계층도입니다.<br>
우리는 코드에서 `HttpServletRequest`의 인터페이스의 인스턴스인 `request`를 만들고 사용합니다. 하지만 자바에서 인터페이스의 인스턴스는 만들 수 없습니다.
게다가 `HttpServletRequest`는 인터페이스이기 때문에 `getSession`이라는 메서드가 정의되어 있지만, 바디가 없는 추상 메서드이므로 실행이 불가능합니다.
따라서 내부적으로 **서블릿 컨테이너** 를 통해 `HttpServletRequest` 인터페이스의 구현체 클래스인 `RequestFacade` 객체를 먼저 생성한 뒤 이것을 `request`에 할당합니다.
구현체인 `RequestFacade` 안에는 `HttpServletRequest` 인터페이스의 추상 메서드들이 오버라이딩 되어 이습니다.
구현체를 할당받은 뒤로 `request` 객체는 `geSession` 메서드를 사용할 수 있습니다.<br>
이후 나오는 `Authentication`, `SecurityContext` 인터페이스의 경우도 마찬가지입니다. 내부적으로는 그 자식인 구현체 클래스를 생성한 뒤 그것을 할당받는 식으로 동작합니다.
이는 객체지향의 **다형성** 이라는 특징이 사용된 아주 중요한 개념이라고 생각해 시작하기 전 이것을 짚고 넘어갑니다.

## 지속 로그인을 위해 쿠키와 세션이 사용되는 방식 및 세션 기반 로그인에서 쿠키의 역할
로그인 과정을 하나씩 짚어가며 설명하도록 하겠습니다. 먼저 로그인 과정을 간단하게 정리해 보았습니다.<br>
1. 로그인 요청
2. 사용자 유효성을 검사
3. 세션 생성
4. 인증 정보 저장 (임시)
5. 인증 정보를 안전하게 관리 (임시)
6. 인증 정보를 안전하게 **전역 관리** (임시)
7. 세션에 인증 정보 저장
8. 로그인 성공 응답
<br>
위 과정을 하나씩 톺아 보도록 하겠습니다.

### 1. 로그인 요청
예시) `https://localhost:8080/api/members/login` url을 통해 Body의 json 과 함께 로그인 요청이 들어온다.

### 2. 사용자 유효성 검사
`memberService.login` 호출한다. ID와 비밀번호를 검증한 뒤 유효성이 확인되면 `MemberLoginResDto` 객체를 반환한다.

### 3. 세션 생성
`request.getSession(true)`를 호출해 세션이 없다면 세션 생성, 세션이 있다면 해당 세션을 반환한다.<br>
세션 ID는 보통 **JSESSIONID** 라는 이름의 쿠키로 전달된다. 이 쿠키가 요청 헤더에 존재하는지를 확인한다.
- **JSESSIONID** 쿠키가 요청 헤더에 존재하는 경우<br>
  쿠키를 받아 세션ID를 확인하는 과정은 Spring과 서블릿 컨테이너에 의해 자동으로 진행된다. 이후 서블릿 컨테이너가 세션 저장소에서 해당 세션ID와 매칭되는 HttpSession 객체를 찾아 반환한다.<br><br>
- **JSESSIONID** 쿠키가 요청 헤더에 없는 경우<br>
  난수 알고리즘으로 새로운 세션ID를 생성한다. 이를 담은 HttpSession 객체를 반환한다. 서블릿 컨테이너가 세션 저장소에 객체를 저장한다.<br><br>

### 4. 인증 정보 저장 (임시)
id와 비밀번호 등의 사용자 인증 정보를 담는 `Authentication` 객체를 만든 뒤, 원하는 구현체를 통해 **검증된 인증 정보**를 저장한다. `어쩌고저쩌고~Token` 이라는 이름의 다양한 구현체가 존재한다. 
ex) `JwtAuthenticationToken`, `OAuth2AuthenticationToken`

### 5. 인증 정보를 안전하게 관리 (임시)
`SpringSecurity`에서 사용하는 `SecurityContext` 객체에 `Authentication` 객체를 할당해 사용자의 인증 정보를 저장한다. SpringSecurity를 통해 안전하게 관리된다.

### 6. 인증 정보를 안전하게 **전역 관리** (임시)
현재 스레드에 할당된 사용자 인증 정보를 관리하는 `SecurityContextHolder` 객체의 `setContext()`메서드를 통해 `SecurityContext` 객체를 등록한다. 
**스레드 로컬** 방식을 통해 요청별 인증 정보를 안전하게 분리해 주고, 보안 관리를 도와주며, 어플리케이션의 모든 계층에서 접근할 수 있도록(전역 관리가 가능하도록) 해준다.

### 7. 세션에 인증 정보 저장
지금까지의 과정이 모두 **임시**였던 이유는, 그 과정들이 모두 **요청 스레드**에 임시저장된 상태로 실행되었기 때문이다. 이 상태에서는 요청이 종료되면 `ecurityContext`와 `Authentication`의 정보가 초기화된다. 
따라서 이후 요청에서도 인증 정보가 유지될 수 있도록 스레드가 들고 있는 SecurityContext를 `session.setAttribute`를 통해 세션에 저장한다.

### 8. 로그인 성공 응답
만들어진 세션의 ID가 JSESSIONID 쿠키에 포함되어 HTTP Response Header의 Set-Cookie 필드에 추가되어 전송된다.

<br>

## 서버가 로그인한 사용자를 인식하는 방식 결론
클라이언트로부터 로그인 요청이 오면 서버는 **세션**을 생성한다.<br>
로그에 성공하면, 서버는  ‘세션ID’ 를 담은 ‘JSESSIONID’ 쿠키를 포함시켜 응답한다.(HttpResponse)<br>
이후 클라이언트는 모든 요청에 ‘JSESSIONID’ 쿠키를 포함시킨다.(HttpRequest)<br>
이후 서버는 다른 모든 API의 시작 부분에서 세션ID를 확인하는 과정을 거친다.<br>
<br>
즉, 세션 기반 로그인에서 쿠키는 **세션ID를 담아 전달**하는 역할을 한다.

레퍼런스
- https://e-una.tistory.com/57
- https://velog.io/@gmtmoney2357/스프링-시큐리티-Authentication-SecurityContext

<hr>

# 서버 구현시 보안적으로 고려해야할 부분

## 1. 세션 관리
1. 최대 세션 허용 개수 관리
   여러 사용자가 한 아이디로 접속했을 때의 문제를 방지해야 합니다.
   `SecurityConfig`의 `securityFilterChain` (이하 필터 체인) 에서 세션의 최대 허용 개수와 여러 사용자가 동일한 아이디로 접속시 세션 제어 방식을 설정할 수 있습니다.
   ![세션관리](https://github.com/user-attachments/assets/a7b63a98-9358-4375-86f5-ca20535f3544)

3. 세션 고정 공격 방어
   공격자가 서버로부터 정상적으로 세션ID를 발급받은 뒤, 희생자가 그 세션ID를 통해 서버로 접속하도록 하는 '세션 고정 공격'을 막아야 합니다.
   필터 체인에서 사용자가 인증에 성공했을 때 기존 세션의 정보를 어떻게 수정할 지 설정할 수 있습니다.
   ![세션고정공격방어](https://github.com/user-attachments/assets/0bf8be59-0f2d-4c83-9875-f62c6b5008cf)

레퍼런스 : https://velog.io/@dailylifecoding/spring-security-session-management-1

## 2. CSRF보호
세션 ID를 가진 사용자를 통해 공격자가 원하는 요청을 서버에 보내도록 하는 CSRF 공격을 막아야 합니다.
1. Referer check
   HTTP Request Header의 Referer 값을 통해 해당 요청이 어떤 URL을 통해서 이루어졌는지 알 수 있습니다.
   보통 중요한 정보의 변경 등은 해당 웹사이트 내부에서 이뤄지는 경우가 많으므로 HTTP Header의 HOST 값과 Referer 값이 동일한 지 확인하는 방법이 이습니다.
   하지만 Referer 헤더는 클라이언트에서 쉽게 변조가 가능해 잘 사용하지 않는다고 합니다.
3. CSRF 토큰 사용
   HTTP Request 가 아닌, HTML의 form 태그 내부의 type="hidden" 필드로 보낼 수 있는 CSRF 토큰을 사용해 방지가 가능합니다. 필터 체인을 통해 설정 가능합니다.
4. CAPCHA 도입
   CAPCHA를 도입해 CAPCHA 인증 코드를 확인하는 식으로 방지가 가능합니다.
![CSRF](https://github.com/user-attachments/assets/6ff8f8d9-8434-4ba3-bd89-a98348f13e01)


레퍼런스 : https://devscb.tistory.com/123

## 3. CORS설정
  브라우저는 기본적으로 "같은 출처에서만 리소스를 공유할 수 있다" 라는 SOP(Same Orgin Policy)규칙을 따릅니다.
   서비스를 만들다 보면 외부 리소스를 가져올 경우가 생기는데, SOP규칙에 따라 이것은 불가능합니다.
   하지만 외부 리소스를 가져오는 것이 불가피할 때, 이를 해결하기 위해 CORS에서 요청을 허용해줄 URL을 설정해 다른 출처간의 리소스 공유가 가능해집니다.
   
레퍼런스 : https://velog.io/@hunjison/SOP-CORS는-보안에서-왜-필요할까

## 4. HTTP 응답 헤더 보안
  서버에서 브라우저에게 보내는 응답 헤더에 보안 지침을 전달해서 보냄으로써 여러가지 공격을 방지할 수 있습니다. 필터 체인을 통해 설정 가능합니다.
