# 로그인 로직

## 1. 사용자 관점에서의 로그인 과정 흐름
1. 사용자가 로그인 페이지에 접속하였습니다.
2. 사용자 ID와 비밀번호를 입력한 후, [로그인] 버튼을 눌렀습니다.
3. 사용자가 입력한 ID와 비밀번호 정보가 서버로 전송됩니다.

    * **`3-1. 로그인 성공 사례`**
        * 서버로 넘어온 사용자의 정보가 회원가입시 DB에 저장된 정보와 일치하여 로그인에 성공합니다.
        * 사용자는 일정기간이 만료되거나, 강제 로그아웃 당하거나, 스스로 로그아웃을 하지 않는 한, 동일한 웹페이지에 재접속했을 때 재로그인을 하지 않아도 됩니다.(로그인 유지)
        * 사용자는 인증된 사용자만 접근 가능한 마이페이지와 같은 페이지에 접근할 수 있습니다.

    * **`3-2. 로그인 실패 사례`**
        * DB에 저장되어 있지 않은 정보이거나, ID와 비밀번호가 모두 입력되어있지 않은 경우 로그인에 실패합니다.
        * 사용자는 로그인에 실패했다는 오류메시지를 확인할 수 있습니다.

## 2. 서버가 로그인한 사용자를 인식하는 방식
### 2-1. 로그인한 사용자를 서버가 지속적으로 인식하기 위해 쿠키와 세션이 어떻게 사용되는지 설명하세요. (서버 딴에서 api 호출할 때마다 어떤 일이 일어나는지.)

사용자가 로그인 폼에 입력한 정보와 회원가입시 DB에 저장된 정보가 일치하면,(이를 `인증과정`이라고 합니다) 그 때부터 본격적으로 `쿠키와 세션`이 사용되기 시작합니다.

사용자 인증 성공 시, 서버는 `세션ID`를 생성하여 이를 `쿠키`에 담아 사용자 브라우저(클라이언트)에 전달합니다.
(서버는 응답 헤더에 `Set-Cookie`를 포함하여 쿠키를 생성하고 클라이언트에게 보냅니다)

그리고 서버는 '세션ID' + '해당 사용자의 최소한의 정보' 를 `세션 저장소`에 저장합니다.
여기서 말하는 세션 저장소는 사용자 회원가입 시에 사용자 정보가 저장되는 DB와는 다른 곳입니다.

브라우저는 `Set-Cookie` 헤더를 보고 쿠키를 브라우저의 `쿠키 저장소`에 저장합니다.

이후, 브라우저는 서버에게 요청을 보낼 때마다(=서버 딴에서 api 호출할 때마다) `세션ID`가 담긴 쿠키를 `Cookie` 헤더에 포함하여 서버로 전송합니다.

요청을 받은 서버는 `Cookie` 헤더에 포함된 `세션ID`를 확인하고, 세션 저장소에서 해당 세션ID를 조회하여 해당 세션이 유효한지 판단합니다.

세션이 유효하면, 서버는 이 세션에 저장된 사용자 정보를 통해 요청을 처리하고, 해당 사용자가 인증된 사용자임을 확인하게 됩니다.

서버는 이 과정에서 사용자 권한도 확인하여, 사용자가 요청한 API에 접근 권한이 있는지도 확인할 수 있습니다.

만약, 세션이 유효하지 않다면 사용자는 재로그인을 해야합니다.

### 2-2. 쿠키가 세션 기반 로그인에서 어떤 역할을 하는지 구체적으로 서술하고, 특히 세션 ID가 쿠키에 저장되어 클라이언트와 서버 간에 전달되는 과정에 대해 설명하세요.
- 세션 기반 로그인에서 쿠키는 **`브라우저와 서버 사이에서 세션ID를 전달하기 위한 매개체`** 역할을 합니다.
- 로그인 폼에 입력된 사용자 정보가 DB에 저장된 사용자 정보와 일치하면, `서버는 세션ID를 생성하고 이를 쿠키에 담아 다시 브라우저로` 보냅니다.
- 서버는 세션 저장소에 세션ID와 기본적인 사용자 정보를 저장하고, `브라우저는 서버가 보낸 쿠키를 받아 쿠키 저장소에 저장`합니다.
- 사용자가 웹페이지를 방문할 때마다 `브라우저->서버`로 요청이 발생하는데, 이 요청에는 항상 `사용자의 세션ID가 담긴 쿠키가 함께 전달`됩니다.
- 그러면 서버는 브라우저로부터 받은 `세션ID가 세션 저장소에 있는지 찾고`, 만약 존재하면 해당 사용자가 인증된 사용자라는 것을 확인할 수 있습니다.

## 3. 세션을 구현할 때 보안적으로 고려해야할 부분
**1. 세션 하이재킹 문제**
공격자가 사용자의 세션ID를 탈취하여 악용할 가능성이 있습니다.
사용자가 로그인할 때마다 세션ID를 재생성하여 보안성을 강화합니다.

**2. XSS 공격, 중간자 공격, CSRF 공격**
서버가 클라이언트로 쿠키를 보낼 때, 'Set-Cookie' 헤더를 통해 쿠키를 설정합니다.
이 때, 여러 옵션을 지정하여 보안 설정이 가능합니다.
```http
Set-Cookie: JSESSIONID=abc123xyz456; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=3600
```
- HttpOnly 옵션: JavaScript 에서 세션 쿠키에 접근하지 못하도록 합니다.(XSS 공격을 통한 세션ID 유출 방지)
- Secure 옵션: HTTPS 연결에서만 세션 쿠키가 전달되도록 설정합니다.(중간자 공격 발생 가능성 감소)
- SameSite 옵션: CSRF 공격에 대한 방어를 강화합니다. SameSite=Strict 은 쿠키가 동일 사이트에서만 요청에서만 전송되도록 제한하여, 외부 사이트에서 세션 쿠키가 유출되지 않도록 합니다.

**3. 오래된 세션의 악용 문제**
세션 만료 기간을 설정하여, 오래된 세션을 관리합니다.
또한, 로그아웃 시에도 세션을 완전히 삭제하여 더 이상 세션 정보가 사용되지 않도록 합니다.

**4. 세션 저장소 보안 문제**
세션 저장소에는 중요한 사용자 정보도 담겨있으므로, 접근 권한을 철저히 제한해야합니다.
또한, 세션 데이터가 네트워크를 통해 전송될 때는 HTTPS 와 같은 암호화된 채널을 사용합니다.

**5. 비정상적인 활동 문제**
동일한 세션ID로 갑자기 다른 IP나 디바이스에서 접속하는 것과 같은 비정상적인 패턴이 발견되면 세션을 강제로 만료시키거나 알림을 생성합니다.

**6. CSRF 공격 문제**
Set-Cookie에 SameSite 옵션을 설정하는 것 이외에도 CSRF 방지 토큰을 사용합니다.
이는 서버와 클라이언트 간에 고유한 인증 토큰을 주고받는 방식으로, 세션ID만으로는 요청이 수행되지 않고, CSRF방지 토큰이 있어야 요청이 수행됩니다.
